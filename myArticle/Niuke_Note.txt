	----掌握至少一门编程语言，就C/C++而言，要熟练语言的基本语法；常用的关键字，如static、virtual，friend等的作用；熟悉 C程序的内 存布局；熟悉STL库函数以及容器和常见算法的底层机制；虚函数实现机制等，这些都是在面试中一遍遍被问到的。一些C/C++程序员需要看的书：《C程序 设计语言(第2版_新版)》《C陷阱与缺陷》、《C专家编程》（没看完）、《C和指针》、《Essential C++》、《C++ primer》（或《C++ primer plus》）、《C++沉思录》（没看完）、《STL源码剖析》、《深度探索C++模型》
       数据结构和算法肯定是必须掌握的。数据结构一般到二叉树就可以了，图等结构掌握遍历、最短路径算法、最小生成树算法的思想、复杂度等即可。算法的话，最常见的就是和数组、链表相关的，难度都不是很大。算法相关的书：《算法导论》（看了部分）、Mark Allen Weiss的《数据结构与算法解析》（强烈推荐，很不错）、《剑指offer》、《编程之美》、《编程珠玑》
      网络、操作系统、数据库这些都需要掌握基本内容，随便一本书就可以了。


1. 网络
	1.1 1）OSI参考模型。
		应用层：
			提供网络和用户应用软件之间的接口服务。
		表示层：
			提供格式化的数据表示和转化的服务。如数据的压缩和解压缩，加密和解密等工作都是由表示层完成的。
		会话层：
			提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录，就是由会话层完成的。
		传输层：
			提供建立，维护和取消传输链接功能，住着可靠的传输数据。
		网络层：
			处理网络间路由，确保数据及时传送。将数据链路层提供的帧组数据包包中封装有网络层包头，其中含有逻辑地址信息——源站点和目的站点地址的网络地址。
		数据链路层：
			实现数据的无差错传送。它接收物理层的原始数据位流以组成帧(位组），并在网络设备之间传输。帧含有源站点和目的站点的物理地址。
		物理层：
			提供机械、电气、功能和过程特性。如规定使用电缆和接头的类型，传送信号的电压等。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理。
	
	1.2 tcp/ip协议模型
		TCP/IP参考模型分为四层：应用层（Application Layer）、传输层（Transport Layer）、网络层（Internet Layer）、链路层（Link Layer）。 
		TCP/IP分层	协议										OSI 分层
		应用层		FTP,SMTP,Telnet,DNS,SNMP,https,http,		7
		传输层		TCP,UDP										4
		网络层		IP, ICMP,(RIP, OSPF),ARP, RARP				3
		链路层		Ethernet,Token Bus,Token Ring,FDDI,WLAN		2,1

	1. 应用层：
		该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。如, 
		HTTPS(Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL),安全超文本传输协议。 HTTP(Hypertext Transfer Protocol),超文本传输协议。 TELNET (Teletype over the Network, 网络电传) ，通过一个终端(terminal)登陆到网络(运行在TCP协议上)。 FTP (File Transfer Protocol, 文件传输协议) ，由名知义(运行在TCP协议上) 。 
		SMTP (Simple Mail Transfer Protocol，简单邮件传输协议) ，用来发送电子邮件(运行在TCP协议上) 。 DNS (Domain Name Service，域名服务) ，用于完成地址查找，邮件转发等工作(运行在TCP和UDP协议上) 。 NTP? (Network Time Protocol，网络时间协议) ，用于网络同步(运行在UDP协议上) 。 SNMP (Simple Network Management Protocol, 简单网络管理协议) ，用于网络信息的收集和网络管理。 
	2，传输层 
		该层提供端对端的通信。最重要的传输层协议是传输控制协议TCP。 
		传输控制协议TCP (Transport Control Protocol) - 数据流传输（面向连接，可靠） 
		用户数据报文协议UDP (User Datagram Protocol) - 数据报文传输(无连接不可靠) 
	3，网络层 
		该层负责数据转发和路由。从该层上面往下看，可以认为底下存在的是一个不可靠无连接的端对端的数据通路。最核心的协议当然是IP协议。此外还有ICMP，RIP,OSPF,IS-IS,BGP,ARP,RARP等。

	4、
 		GET:通过请求URI得到资源,
 		POST:用于添加新的内容,
 		OPTIONS:询问可以执行哪些方法,TRACE:用于远程诊断服务器,
 		HEAD:类似于GET,但是不返回body信息，用于检查对象是否存在，以及得到对象的元数据 
 		HEAD,GET,OPTIONS和TRACE视为安全的方法，因为它们只是从服务器获得资源而不对服务器做任何修改，但是HEAD,GET,OPTIONS在用户端不安全。而POST则影响服务器上的资源
	5、 MAC地址是设备出厂时就设定好的，全球唯一的地址，供在网络中识别设备
		MAC（Media Access Control，介质访问控制）地址，也叫硬件地址，长度是48比特（6字节），由16进制的数字组成，分为前24位和后24位：前24位叫做组织唯一标志符（Organizationally Unique Identifier，即OUI），是由IEEE的注册管理机构给不同厂家分配的代码，区分了不同的厂家。
		后24位是由厂家自己分配的，称为扩展标识符。同一个厂家生产的网卡中MAC地址后24位是不同的。

	6、RIP协议是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信
		息的传递。RIP协议基于
		距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。距离就是通往目的站点所需经过的链路数，取值为1~15，数值16表示无穷大。
		对于小型网络，RIP就所占带宽而言开销小，易于配置、管理和实现，并且RIP还在大量使用中。若采用RIP协议，其网络内部所经过的链路数不能超过15，这使得RIP协议不适于大型网络。

	7、路由算法修改路由表的基本目的是将最好路由信息添加到路由表中，路由的 
		好坏是由路由算法根据自己获得的路由信息计算出来的。对于每一条路由， 路由算法产生一种权值来表示路由的好坏。通常情况下，这种权值越小，该路径越好。 路由权的计算可能基于路径某单一特性计算，也可能基于路径多种属性进行计算。

	8、TCP是面向连接的服务；三次握手（建立连接）和四次挥手（关闭连接）；使用滑
		动窗口机制进行流量控制；TCP要保证在所有可能的情况下使得所有的数据都能够被投递，当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭一方则转入CLOSED状态，这的确能够保证所有的数据都被传输。
		
		1）首先A B端的TCP进程都处于established状态， 当A的应用程序传送完报文段，就会去 主动关闭 连接。A 会停止发送报文段（但是还会接收），并向B发送[FIN = 1,seq=u]数据，之后进入FIN-WAIT-1状态；
		
		2）B接收到A发送的请求之后，会通知应用进程A已经不再发送数据，B会向A发送ACK确认数据[ACK=1,seq=v,ack=u+1 ],B进入  CLOSE-WAIT状态，  A接收到B发送的数据之后，A进入FIN-WAIT   -2状态；此时A到B方的连接已经关闭了。
		
		3）当B的应用进程发现自己也没有数据需要传送，B应用进程就会发出 被动关闭 的请求，B此时向A发送[FIN=1,ACK=1,seq=w,ack=u+1]数据，并且进入LAST-ACK状态；【所以D不对】
		
		A接收到B发送的数据之后，向B发送确认数据[ACK =1,seq=u+1,ack=w+1],进入TIME-
		WAIT状态，等待2MSL之后关闭连接进入CLOSED状态；B接收到A发送的确认之后进入CLOSED状态。B到A方的连接关闭

	9、奈氏准则和香农定理
		奈奎斯特：在无噪声情况下，码元速率极限值B与信道带宽的关系：B=2*H(Baud)
		奈奎斯特公式----无噪信道传输能力公式：
		
		C=2*H*log2N(bps)
		H为信道的带宽，本题中H=3KHz；
		N为一个码元所取得离散值个数，本题中N=16(4个相位，每个相位4中振幅)。
		C=2*H*log2N=2*3kHz*log216=2*3k*4=24kbps;
		香农公式是在带噪信道容量计算时使用的公式：
		
		C=H*log2(1+S/N)(bps)
		S为信号功率，N为噪声功率，S/N为信噪比；
		
	10、私有IP 地址范围：
		A: 10.0.0.0~10.255.255.255 即10.0.0.0/8
		B:172.16.0.0~172.31.255.255即172.16.0.0/12
		C:192.168.0.0~192.168.255.255 即192.168.0.0/16
		这些地址是不会被Internet分配的，它们在Internet上也不会被路由，虽然它们不能直接和Internet网连接，但通过技术手段仍旧可以和 Internet通讯（NAT技术）。我们可以根据需要来选择适当的地址类，在内部局域网中将这些地址像公用IP地址一样地使用。在Internet上，有些不需要与 Internet通讯的设备，如打印机、可管理集线器等也可以使用这些地址，以节省IP地址资源。

		A类地址：0.0.0.0 ~ 127.255.255.255
		主机号是后24位
		B类地址：128.0.0.0 ~ 191.255.255.255
		主机号是后16位
		C类地址：192.0.0.0 ~ 223.255.255.255
		主机号是后8位
		D类地址：224.0.0.0 ~ 239.255.255.255
		后28位为多播组号
		E类地址：240.0.0.0 ~ 255.255.255.255
		后27位待用

	5.Get请求和Post请求区别 
		答：a、Post是通过Http中的Post机制将表单中的数据提交道Action所制定的程序Get方法是通过Url请求来提交表单数据的。 
			b.Get适用于传输数据量小于1K数据，执行效率高。Post传输数据量较大，但也有限量。 


2、 设计模式：
	单例模式(Singleton)：确保有且只有一个对象被创建。 
	抽象工厂模式(Abstract Factory)：允许客户创建对象的家族，而无需指定他们的具体类。 
	工厂方法模式(Factory Method)：由子类决定要创建的具体类是哪一个。 不影响原有类的功能。 
	装饰者模式(Decorator)：包装一个对象，以提供新的行为。统一处理返回的消息。 
	状态模式(State)：封装了基于状态的行为，并使用委托在行为之间切换。 
	迭代器模式(Iterator)：在对象的集合之中游走，而不暴露集合的实现。 
	外观模式(Facade)：简化一群类的接口。 
	策略模式(Strategy)：封装可以互换的行为，并使用委托来决定要使用哪一个。 
	代理模式(Proxy)：包装对象，以控制对此对象的访问。 
	适配器模式(Adapter)：封装对象，并提供不同的接口。可以使用多个接口。 
	观察者模式(Observer)：让对象能够在状态改变时被通知。 
	模板方法模式(Template Method)：有子类决定如何实现一个算法中的步骤。 
	组合模式(Composite)：客户用一致的方法处理对象集合和单个对象。 
	命令模式(Command)：封装请求成为对象。

	MVC 模式，静态工厂模式, 适配器模式, 门面模式, DAO模式, 单例模式,Template模式. command模式
	在网上看见了这篇文章，作者以轻松的语言比喻了java的23种模式，有很好的启发作用。
	创建型模式
	　　1、FACTORY—追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory
	　　工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。
	　　2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你” builder。（这一定比美军在伊拉克用的翻译机好卖）
	　　建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。
	　　3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。
	　　工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。
	　　4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）
	　　原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。
	　　5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)
	　　单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。

	结构型模式
	　　6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)
	　　适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。
	　　7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了
	　　桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。
	　　8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。” “……”，MM都会用Composite模式了，你会了没有？
	　　合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。
	　　9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？
	　　装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。
	　　10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。
	　　门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。
	　　11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。
	　　享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。

3、 内存：
	代码区：存放代码。
	数据区：存放数据
		1.1 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
		常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
		1.2 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
		1.3 堆：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。（也有编译器malloc也用来管理这里的资源）
		1.4 自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
	----stack 空间有限
	----heap 空间较大


4  C++ 编译系统问题：
	1、 32位机器的指针 是4位，63位机器统一为8位。
		函数参数的中的数组名也是指针类型
			ex: void function(char name[56])
			sizeof(name) = 4;	//在32位系统下

	2、 char :1字节
		short :2字节
		double :8 字节
		long double :10 字节
		others: 4字节

	3、虚函数有虚函数表4字节，空类占用1个字节，若不为空类则不算这个字节，类函数不占空间，
		类的静态域不算在类大小中。
	4.1 C++分配内存必须手动释放，分配失败要进行异常处理，指针最后最好赋值为NULL。

	4.2 标准宏定义：#define MIN(A,B) ((A) <= (B) ? (A) : (B)) 

	4.3 C++函数调用时，参数和函数名压栈顺序为：参数从右向左压栈，最后压栈函数地址
	（Windows平台的栈生长顺序为：由上向下

	4.4 头文件中的 ifndef/define/endif 的作用：
		1> 是预处理命令之一（宏定义，文件包含，条件编译）中的条件编译。
		2> 条件指示符#ifndef 的最主要目的是防止头文件的重复包含和编译。
	
	4.5 函数中声明的指针，不是用malloc或者new时，函数结束会释放，返回的指针是野指针。
		ex: char p[] = "helloword"	//这时分配的内存在栈中，函数结束之后就会被释放。
		free(tyep * p) 函数执行之后，p为野指针，指向未知的内存。

	4.6 assert((strDest!=NULL) && ( strSrc  !=NULL));	//可以进行数据合法检查 

	4.7 运算符优先级：括号，下标，->和.(成员)最高：
        单目的比双目的高；
        算术双目的比其他双目的高；
        位运算(^ & ~ << >>) 高于 关系运算；
        关系运算(>, <, ==, !=, >=, <=) 高于 按位运算（与&&，或||，异或XOR）；
        按位运算 高于 逻辑运算；
        三目的只有一个 条件运算，低于逻辑运算；
        赋值运算仅比 ， （顺序运算）高。
    
    4.8 如何输出源文件的标题和目前执行行的行数？
	答案:
		printf("The file name: %d\n"， __FILE__);
        printf("The current line No:%d\n"， __LINE__);
		ANSI C标准预定义宏:
		_ _LINE_ _
		_ _FILE_ _
		_ _DATE_ _
		_ _TIME_ _
		_ _STDC_ _        当要求程序严格遵循ANSI C标准时该标识符被赋值为1
		__cplusplus__   当编写C++程序时该标识符被定义

	4.9 const 使用问题：
		1> const 修饰变量
			1. c语言中表示一个变量，值不可改变，c++ 类似宏定义#define n，常量
				const int n = 5;
				int array[n];	// c语言不支持，但是c++是可以的
				C标准中，const定义的常量是全局的，C++中视声明位置而定。
				对于常量指针，不能通过该指针来改变所指的内容。
		2> 用法3：const修饰函数传入参数
		    将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。同理，将指针参数声明为const，函数将不修改由这个参数所指的对象。
		    通常修饰指针参数和引用参数：
			void Fun( const A *in); //修饰指针型传入参数
			void Fun(const A &in); //修饰引用型传入参数

		3> 用法4：修饰函数返回值
    		可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。

		4> 用法5：const修饰成员函数(c++特性)
			const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；
			const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；
			const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。
			--另外需要注意的是常量对象不允许调用非常量的函数。
	4.10析构和虚函数的作用
		析构函数也是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载。知识在类对象生命期结束的时候，由系统自动调用释放在构造函数中分配的资源。这种在运行时，能依据其类型确认调用那个函数的能力称为多态性，或称迟后联编。另：析构函数一般在对象撤消前做收尾工作，比如回收内存等工作，虚拟函数的功能是使子类可以用同名的函数对父类函数进行重载，并且在调用时自动调用子类重载函数，如果是纯虚函数，则纯粹是为了在子类重载时有个统一的命名而已。
	4.10 extern 的使用
		1> extern 和 c 联合使用修饰函数名，表示函数在编译阶段按照c语言的去翻
			译函数名，使c语言和c++实现名字对等。
		2> extern 修饰变量，表示这个变量只是声明，编译阶段在别的模块找该变量的定
			义。

	4.11 static 关键字
		A、静态成员函数与类相联系，不与类的对象相联系。
		B、静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的
5、C++编程注意事项：
	5.1 支持变长的数组，C语言不支持。可以用c中的 malloc/c++ 的new 动态分配内存。
		 动态数组：int n = 10;
		 		   int * array = new int[10];
		 		   unique_ptr<int []> array(new int[n]);	// 不需要释放（c++11）
		 		   delete []array;
	5.2 printf() 函数是从右向左进行运算的。
		理解为：int * ptr = 0x10000; printf("%d""%d", * ptr, *(++ptr));
		两次的ptr的值都为 0x10001.
	5.3 输入单个由空格隔开的单词时，可以用while(cin>>str) 
		 输入一行用getline(cin, str)。
		 数据处理可以用 stringstream ss(str); int x; while(ss>>x) a[n++] = x;
	5.4 sort 函数 
		sort(start, end, myfunction);
		bool myfunction (int i,int j) { return (i<j); } //升序  降序(i>j)
		tolower(); 转换为小写
	5.5 字符串
		1> c 风格字符串：	
			char arrayString[20] = "abc";
			const char *arrayString = "adc";
		2> c++ 风格字符串：
	5.6 输入由字符间隔的数字
		string strTemp;
		int array[100];
		int i = 0, max, min;
		stringstream sStr;
	
		cin >> strTemp;
		int pos = strTemp.find(',');
		while (pos != string::npos)
		{
			strTemp = strTemp.replace(pos, 1, 1, ' ');
			pos = strTemp.find(',');
		}
		sStr << strTemp;
		while (sStr)
			sStr >> array[i++];	
	5.7 c++的静态变量只能在类外赋值。	 
6、linux 单元：
	6.1 文件权限操作: chmod
		chmod ［who］ ［+ | - | =］ ［mode］ 文件名¼
     	u 表示“用户（user）”，即文件或目录的所有者。
		g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。 
		o 表示“其他（others）用户”。 
		a 表示“所有（all）用户”。它是系统默认值。 
		操作符号可以是： 
		+ 添加某个权限。 
		- 取消某个权限。 
		= 赋予给定权限并取消其他所有权限（如果有的话）。 
		数字设定法的一般形式为： 
		chmod ［mode］ 文件名¼

    	我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以       数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。 

		例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。 
	6.2 新建用户命令：ueseradd,
		-u 用户号 指定用户的用户号；因为系统用户的用户号为0，故指定用户号为0 如果同时有-o选项，则可以重复使用其他用户的标识号；因为系统本身存在用户号为0的系统用户，故应该使用该参数。
		u表示创建用户.g表示创建用户组 -e指定账号的有效期限，缺省表示永久有效。
		f指定在密码过期后多少天即关闭该账号。-p表示创建密码
	6.3 ctrl  z 就是挂起一个进程，暂停的意思
		fg是将进程放到前台并唤醒
		bg是将进程放到后台并唤醒
        ctrl+h,在shell就是向左删除的作用
    6.4 磁盘阵列的配置文件为/etc/raidtab 逻辑设备为 /dev/md0磁盘阵列

7 数据库
	1、第一范式（1NF）
        在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。
        所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。例如，对于图3-2 中的员工信息表，不能将员工信息都放在一列中显示，也不能将其中的两列或多列在一列中显示；员工信息表的每一行只表示一个员工的信息，一个员工的信息在表中只出现一次。简而言之，第一范式就是无重复的列。

	2、第二范式（2NF）
       第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。如图3-2 员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。
        第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。

	3、第三范式（3NF）
        满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在图3-2的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。
    4、MySQL数据库中，变量分为系统变量（以"@@"开头）和用户自定义变量。系统变量分为全局系
    	统变量(global)和会话系统变量(session)。
		@@global     仅用于访问全局系统变量的值；
		@@session  仅用于访问会话系统变量的值；
		@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；
		sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。
	5、 表操作
		1> 查询昵称为‘luo’的用户列表，降序排列
			select uno from userTable where name = 'luo' order by uno desc;
		2> 成绩最高的学生号
			select sno, max(grade) from sc group sno;
		3> 每科成绩大于90分的人
			select cno, count(sno) from sc where greade > 90 group cno; 

	6、数据库事务是指作为单个逻辑工作单元执行的一系列操作。
		事务的：原子性、一致性、分离性、持久性
8 操作系统
	1、 进程和线程
		进程的状态：执行，就绪，阻塞
	2、 同步异步，阻塞非阻塞
		同步：发出调用时，等待结果
		异步：不直接结果，当结果出来时，通知调用者
		（程序等待调用结果的状态）	
		阻塞：挂起线程，等待结果
		非阻塞：先去做其他的事情，按时检查结果
	3、操作：
		// 在表system.table 中查找年龄大于20姓王的名单并由年龄降序排序
		1、 select * from system.table where age > 20 and name like "王%" order by age desc;
			// CUSTOMER_ID ：（外键）bigint，设置级连删除；
		2、 alter table ORDERS add constraint FK_CUSTOMER foreign key (CUSTOMER_ID) references CUSTOMERS(ID) on delete cascade;
	4、 delete from tablea & truncate table tablea的区别 
		truncate 语句执行速度快,占资源少,并且只记录页删除的日志； 
	　　delete 对每条记录的删除均需要记录日志
